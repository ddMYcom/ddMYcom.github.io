{"meta":{"title":"moyong的博客","subtitle":"欢迎来到moyong的博客","description":"这是一个程序员的网站。。","author":"moyong","url":"http://52moyong.top"},"pages":[],"posts":[{"title":"Say Goodbye---我的大学生活","slug":"Say Goodbye---我的大学生活","date":"2018-05-31T15:11:12.000Z","updated":"2018-06-06T14:29:35.946Z","comments":true,"path":"2018/05/31/Say Goodbye---我的大学生活/","link":"","permalink":"http://52moyong.top/2018/05/31/Say Goodbye---我的大学生活/","excerpt":"","text":"前言毕业回家差不多一个星期了，刚回来似乎感觉跟平常放假差不多。但是在不断地刷朋友圈，看着好多人都在发毕业离开学校的相关信息，宿舍群里，一个个舍友离开学校的消息。突然就明白这个假期是没有期限的，该和我的大学生活说再见了。既然已经结束了，就好好做个总结吧。记录一下自己大学四年的一些心路历程，没什么文采，全当是流水账似的简单记录一下，以后再回头看看，说不定还别有一番滋味在心头。 大一刚上大一的时候，应该说是好奇心特别强的时候，毕竟经过高三一年的奋斗后对大学生活肯定是比较憧憬的。还记得刚来学校开的第一个班会，是两个班同一个专业一起开的，给我们开班会的是我们专业的负责人，那时候他给我们介绍我们的专业，物联网是一个新兴的专业，是集云计算，大数据，智能家居。。。。为一体的专业，吧啦吧啦了一大堆，一个个高逼格的名词不断地出现，听得我是那个热血沸腾啊，然后又给我们介绍了物联网专业的发展趋势，和物联网给我们未来带来的改变。当时真的感觉是进对专业了(确切来说应该是选对专业，因为志愿里我是填有这个专业的，因为高中的时候看一手机杂志也见到过这个名词，然后填志愿的时候发现有这个专业所以就填了，但是并不是放在第一志愿，但是没想到还是进了这个专业，不像我好多同学都是莫名其妙的被被分配来这个专业的)，感觉我们专业就是未来的主宰，而我们将是下个时代的科技发展的推动者。这个专业还有点意思的是很多人问我学的什么专业，我直接说物联网。很多人都说，互联网啊，这个牛逼。。还有人说这专业是不是送快递的。。不，我们是拉网线的。会后的几天，可以去图书馆借书了，就跟几个志同道合的小伙伴去借我们专业相关的书，记得当时真的借了挺多，而且每一本都很厚，当时只是看着书的封面很绚丽，书名很霸气就借回来了，借回来看了一下之后才发现，这TM的写的是什么啊，里面的每一个字都认得，但是连起来后，简直比文言文读起来还困难，堪比天书啊。借回来后也就翻了两三页，然后就一直没动了，想着还是等着老师传道授惑吧～～大学的前两个星期是军训，好像对军训没什么比较印象深刻的事，只记得军训的时候百色的太阳特别的狠，大家都成了黑鬼。军训过后就是迎来了学校各大组织的招聘了，作为萌新，当然是都去尝试一遍啦，最后是进了两个社团：第一个是，1+1创业协会，进这个协会真是挺坑爹啊，除了第一次见面会给我发了条消息(而且当时有事，没有去)，之后再也没消息了，除了有本会员证，似乎就跟这协会没啥联系了，不过也可以理解，毕竟这个协会人数还是挺多的，管理不到位也是可以理解。第二个是足球协会，高中的时候还是挺喜欢踢球的，虽然都是乱来，就图个大家一起起哄开心。虽然足协人数是少了点，但是都是非常热情的，有很多个学长都很热心的带我踢球，虽然是挺喜欢踢球的，但是自己的球技真的太烂了，有时候太忙了也没有去练习，然后平时有一些交流赛之类的，学长们经常叫我们参加，但是总觉得自己球技太烂，所以都没有积极的上场。现在想想大学比较后悔的事就是没有好好的练习踢球，没有正式参加过一场比赛。除了加入社团，还加入了社联的外联部，和系学生会的实践部。能加入这两个组织，其实应该说是贵人相助了，凭自己的面试表现估计是一个都进不了的，所以还是真心的感谢帮助我的人，让我加入这两个很优秀的组织。在社联的外联部，待了一个学期，然后没有去参加二轮的面试，原因也很简单，外联部是要出去拉赞助的，拉赞助确实挺锻炼人的，但是想要拉到赞助还是需要比较能说会道的吧，而从自己出去拉赞助的表现来看确实并不擅长这个，而且社联需要每个星期都要进行值班，自己加入的组织比较多，时间是有点支配不过来的，所以最终就选择退出了。然后系学生会实践部呢，感觉在这个组织里面还是比较充实的，虽然工作都是比较简单，收收材料，盖盖章的。偶尔出去做做义工啥的，还是挺不错的，因为实践部属于分团委，所以经常要和组织部宣传部一起工作，所以还是挺热闹的，每个星期开会听听师兄师姐们讲讲道理，吹吹牛逼，气氛还是挺棒的。真心觉得这个组织里的人都很优秀，都是我学习榜样。还有我们实践部的两个部长，人真的很好，经常请我们去吃东西，带我们玩～在这个部门待了一年，到换届的时候还是没有选择留下来，因为觉得自己在组织能力和领导能力上都比较弱，所以觉得还是让有能力的人上吧。大一的上学期还是挺充实的，各种活动，各种工作，学习。不过到了大一下学期似乎就变得有点散漫了，退了一些组织之后，平时也不怎么忙了，基本上就只有系学生会这边有些工作，或者活动去参加一下，其他时间都是在宿舍看电影，看电视剧，玩手机(游戏我是不玩的，我也不知道为啥对游戏没什么兴趣)，上课除了大一上学期比较认真听之外，到大一下学期懂得套路之后，就在也没怎么听了，有时候想认真听下课吧，听着听着，自己就走神了。。感觉已经回不到高三认真听课的状态了。上课经常都是在刷微博，刷知乎，刷贴吧，各种刷。刷着刷着大一就结束了。大一的遗憾应该就是没能好好练习踢球，去没正式参加过一场足球赛吧。 大二大二了，离开学生会后，似乎就更闲了。基本上都是每天上课玩手机，下课就回宿舍看电影，睡觉，继续玩手机。。。突然有一天刷贴吧碰到一个帖子，是关于旅行的，楼主也是学生，然后自己挣钱去旅游之类的，看了那篇帖子，真的是羡慕不已啊，然后跟随着这篇帖子就关注了穷游吧，旅行吧，看着里面很多精彩的帖子，非常羡慕啊。然后也给自己下了个目标，挣钱旅行，然后开始第一步就是制定自己的旅行计划，当时好像是计划去了好几个城市吧，算好大概得经费后就开始了一个学期攒钱+挣钱，然后寒假就出发的计划。攒钱的话，只能从自己的生活费中省，一个学期想要省去几个城市玩的经费似乎不太现实。所以只好自己出去挣钱咯，刚好大一时认识了个学长，是卖联通卡的，因为之前暑假有在手机店卖过手机，有接触过卡相关的业务，所以当时那个学长来推销卡的时候，加了学长的联系方式，大一的时候，就作为他的下线，有人办卡就联系他。其实当时也没怎么用心去做这个，然后大一暑假的时候，他说开学有别的事要做，就不继续做联通这边的业务了，问我要不要接替他的位置，跟校园负责人直接联系。当时觉得还是挺能锻炼自己的，就接下了，然后自己也拉了个小团队一起卖卡⊙∀⊙！想法是很好，但现实总是残酷的。开学的时候，自己在大本营坐着，来办卡的人确实寥寥无几，自己建的小团体也是都是有自己的事情要忙，加上之前有些事情没有沟通好，所以也没起到什么作用，还有学校很多都是推荐使用的移动卡，所以联通这边的销量确实不是很理想。然后联通负责人就建议我们去扫楼，扫楼的结果是，其他人都拿到不错的业绩，而我确实0业绩，确实挺尴尬的，自己在营销和沟通能力上确实比较弱。所以在卖卡这边也是没挣到啥钱。然后紧接着又通过一个学姐认识了一个西安交大的硕士，在百色这边推广一个能生成微信二维码支付的产品，在招业务员推广这款产品，当时觉得这款产品确实挺有市场前景的，然后就想在继续锻炼锻炼一下？当时能够推销出一款产品能得到的利润还是挺高的，几乎是等价于产品的价格。在这里也可以看出来前期要推广一个产品确实需要很大成本，而且当时去推广只要商家是有意向的，告诉他，他再去谈，谈成功的话也算我们的，所以觉得还是挺好的，所以就去打算尝试一下，说不定还没能赚到钱呢。然后他就找个时间给我们介绍了一下这款产品的一些功能，教我们如何去向商家推广，相当于做个简单培训吧。后面陆陆续续又有一些总部的线上培训，当时在宿舍听培训的课程，舍友们还以为我进了传销组织。。。具体了解了这款产品后确实觉得还是挺不错的，用户在买单的时候可以生成订单的纸质二维码，用户直接可以扫码付款，只要扫码后就能够直接关注本店的微信公众号，买这款产品还可以免费帮搭建本店的公用号，而且这款产品在当时推广也不是很贵，印象中好像是一千来块吧，所以结合这些优势，我觉得应该能卖得出去吧，遗憾的是真正去推广的时候，真的是磨破了嘴皮也没人愿意接受这产品啊。不过当时微信支付在百色确实也还没流行，大多数还是喜欢现金支付。所以又是一次失败的经历啊，后面这款产品也没能在百色推广起来，而那个硕士大哥又继续回去读博去了，其实这位大哥人还是挺优秀的，只不过可能选错了推广地点吧。然后在这段时间也在不断地关注穷游吧，旅行吧的一些动态，看到人家去玩拍的一些照片真的是太美了，然后又关注到了摄影吧，真的是里面个个都是人才啊，拍的照片一张比一张牛逼，就逐渐的中了摄影的毒，后面又不断地关注单反吧，进了毒德大学的世界⊙∀⊙！然后就想着去旅行要是有个相机去记录这些美景那该多棒啊，所以又改了计划，上学期先挣钱买相机，下学期再挣钱旅行，简直就是完美的计划啊⊙∀⊙！。所以又不断地关注学校的兼职信息，突然有一天发现一条兼职信息，是一个婚礼摄像工作室学徒，看到这条信息的时候感觉真的是来得正是时候啊，又能跟着学摄影的一些技巧，又能挣点钱，简直完美啊，于是就写了份简历发过去，没想到真的就能去面试了，也不知道当时哪里来的勇气，单反都没接触过的我就直接冲去面试了(°_°)…其实面试也没什么，只是表达了一下自己对这方面感兴趣，想去学习，后面一直都是他在跟我聊一些理想梦想之类的东西。可能觉得我态度还是比较诚恳，所以就决定让我试试吧。之后就一直跟他去拍了几场婚礼，前面一直是在跟着学怎么拍，最后面终于可以自己去拍了，虽然只是拍婚礼的敬酒场面，但是内心还是比较激动的，虽然平时跟着学也大概能知道该怎么做，但是自己真正实战的时候确实有点手忙脚乱的感觉，结果拍出来的感觉确实很不理想。然后又让我去学视频剪辑，然后学了一些简单的操作，就帮忙剪一些画面的片段。后面他确实比较忙，也没时间带我，又比较急需能直接上手的人，所以觉得自己还没能力承担这份工作，就没有再去了，想着等自己的能力提升点在去试试吧。这份兼职还是没挣到啥钱，不过确实让我学到了很多摄影方面的一些基础知识，相机一些参数的调节，以及对摄影的兴趣，还是比较有意义的，因此也更加坚定了我想买相机的想法。想法是有了，但是实现还是比较困难啊，正在我一筹莫展的时候，商机又来了⊙∀⊙！我一个朋友在做一些网络投资，然后问我有没有兴趣，想要带我一起做，刚开始见他每天都在晒收益而且还特别高，他刚叫我投资的时候我确实还是不太敢做，毕竟想要有更多的收益还是需要比较大的投资资本的，而且是搞网络投资风险太大，对这些东西也不是很熟，虽然看起来整个流程确实都挺正规，基本上就是交保证金领相应的任务，然后做完任务后就可以领取相应的收益，而这些任务太多是看广告，下载一些游戏app做一些通过一些关卡就能完成的。当然这个平台里还有很多获取收益的方式，所以能得到的收益也是非常的多，但是觉得高收益下必有高风险。所以刚开始确实不太敢玩。后来见他一直晒每天的收益，终于顶不住诱惑入坑了。。。入坑之后真的发现这个平台确实好啊，有线上产业又有线下实体产业，确实是个很棒的平台啊，不过好景不长，平台前期发展确实能有不错的收益，但是这个平台用户量不断上升后，也逐渐趋于稳定了，所以很多高收益的任务，也逐渐没有了，收益也慢慢的降低，到最后如果资金不是很多基本上就只有和余额宝一样只会有一些存储的利息了，所以就觉得没啥可搞了，反正也小挣一比了，加上自己一些生活费也够买相机了。所以就退出了这个平台，买了相机。相机是有了，但是旅行的经费还是没有啊，就在这时候，我那朋友又找到了一个新的平台，这个平台和上一个不同，玩的是资金盘，这个平台的收益很高，高的确实有点很离谱，而且是不需要做什么任务的，只要到时间了就可以获得收益，相比于上个平台的运营模式，确实很不靠谱。但是还是有很多人在玩，所以就决定尝试一下，刚开始还是小投资试试，前两次的投资还算成功，不过投资不多所以收益也不是很高，后面跟朋友商量，最后再投一次搞大一点，然后就收手，那次基本上是把所有生活费都投进去了，还额外借了点钱，最后面果然是投资有风险啊，平台崩盘了。。。那时候真的是心拔凉拔凉的啊。在这个平台上玩的人还是挺多的，当时崩盘了在全国还是闹得挺严重的，很多百万级玩家啊，有很多也是把家当都投进去了，对比之下自己还算好的了，不过还是挺苦逼啊，欠了一屁股债，生活费也没多少了，又不好意思跟家里开口，毕竟之前还跟家人说自己能挣了点外快⊙∀⊙！。高利润果然存在高风险啊，要是当时学会分散投资，也不会亏的那么惨了，当时都有想把相机卖掉的冲动了，但是想想刚买不久，确实有点不甘心啊，所以还是忍住了没卖。。只好辛苦点慢慢把坑填上了。然后也是差不多学期末了，正好百色的芒果要准备开卖了，班里就有个小伙伴叫我一起合作卖芒果，正好缺钱，那就干咯，于是就拉上了几个小伙伴一起轰轰烈烈的搞起小团队来(⊙o⊙)…卖芒果的想法确实很好，但是过程也是十分的辛苦啊，芒果季也是百色最热的时候，每天要去拉芒果回来然后又要包装装箱等一系列的活，那时候课程还是挺多的，所以一般都选择中午进行包装，所以一般中午都是不睡觉的，要知道在百色这种炎热的天气下中午不睡觉，下午简直是整个人都不在状态啊。不过刚开始总是艰辛的，后面慢慢的掌握其他进货渠道后就没那么累了。总的来说，结果还是挺好的，虽然中间遇到很多挫折，但是大家都坚持下来了，钱虽然挣得不是很多，但是真的是一段很难忘的经历，非常的感谢一起合作的小伙伴们⊙∀⊙！。就这样，之前的坑再慢慢的填完，大二也就慢慢的结束了。大二的遗憾应该也就是没能去成自己计划的旅行了。 大三一转眼也就来到大三了，经历了大二的那次大劫之后，在也不想啥不切实际的挣钱方式了，到了大三确实也是在大学生活里的最后一年了吧，毕竟大四是要出去实习的，这一学年的开始确实是开始迷茫了，自己前两年是属于没把学习当成重心的，基本上每次上课都属于托管状态的，每次到考试的时候基本都是靠考前找各路神仙收集重点加上考场的布阵，以及队友的辅助才能顺利通过的。所以，对于以后从事本专业的工作确实比较有难度的。而且这个专业方向还这么大根本就不懂以后要从事什么职业，然后就想着既然对摄影感兴趣要不要尝试一下走这条路线，但是在看看之前自己拍的一些东西，想想还是算了吧，确实没有一张照片是可以拿出手的，而且也不是很想把这个兴趣当做职业去做，所以还是打消了这个念头。既然还是迷茫那里随缘走着吧。然后呢，新学期的开始，隔壁的一个小伙伴就来问我要不要去健身，刚开始这个建议挺好的，毕竟自己也挺胖的，万一去健身瘦下来了呢⊙∀⊙！不过当时还是有点犹豫的，怕自己真的坚持不了，只是三分钟热度而已。但是想想反正自己也没事干，去试试也好啊，就这样，我的漫漫健身之路就开始了。刚开始去的时候每个人都是热情似火啊，基本上一去到就先跑个半小时，然后在怼各种器材，基本上每天都是大汗淋漓的回学校，我们一般都是下午6点钟左右去的，大概运动一个多小时，要是晚上没有课的话，一般都会在右医后门吃碗砂锅粥，看看来往的路人，吹吹牛逼~简直就是美滋滋~还真是怀念健身那段日子啊。后面慢慢坚持久了，感觉真的是成习惯了，有时候其他小伙伴没空，自己一个人也去练上一个小时。不过我对其他练肌肉的器材是不太敢兴趣的，每次去基本上是先去跑步机跑个半小时，然后做几组仰卧起坐，然后在打打拳，偶尔踩踩单车。大三上学期似乎也没什么很多的事，每天健健身，偶尔周末出去拍拍照~不过大三上学期开始没多久我们专业被南宁的一家和学校合作的培训机构拉过去实训的十天的JavaEE开发，当时的我可是连Java的语法都没会的，上课的时候跟着老师敲着敲着，也能敲出个效果，就是不知道是啥意思(⊙o⊙)…做完这个小项目后就是一轮疯狂的洗脑了，各种忽悠去他们那里培训，当时我们班好像还是挺多同学想去的。不过我是没啥感觉，因为那时也没确定要不要往这方面发展，就算要往这方面发展去培训，也要对比一下其他机构嘛，毕竟培训费并不便宜。就这样大三上学期一晃也就过了还是啥也没会。寒假的时候确实有点迷茫啊，不懂自己未来要从事什么职业，该走哪个方向。然后就想着要不就跟着大众的脚步去培训吧。然后就开始对比了一下各大培训机构，选好之后就等着那家培训机构来学校宣传了。大三下学期安排的课程并不多，然后陆陆续续的来了很多培训机构来学校宣讲，但是自己比较心仪的那家倒是没有见，然后就想着自己什么基础也没有如果去培训的话是不是会跟不上，后来就去网上找了一套培训机构的视频来看看，想自己学着点基础的东西吧。然后又开启了我的慢慢Java学习之路~基本上是除了正常的上课，吃饭，洗澡睡觉之外。一有时间就看Java的视频教程，周末没有什么活动的话也是在看Java的视频教程。一边看一边也跟着敲，基本上视频上讲的东西都跟着敲了一遍(⊙o⊙)…虽然是跟着视频上学的，但是自己也没什么基础，有时候遇到个问题都要搞好久，幸好我宿舍有个大神，之前也一直在学Java，有时候遇到不懂的问题还可以问他。自学的过程本身就很艰苦，要是没有人指导估计学的也会很慢，所以想要自学一定要找个能一起学的，不然很容易就会放弃的。但是每天都在敲代码，总感觉有点枯燥啊，所以就想找点能放松的事情来做，去健身应该是不可能了，每天健身回来都会比较累，估计也不想敲代码了吧。虽然不去健身了，但是每天晚上还是坚持去跑步的。因为寒假的时候有接触过吉他，所以就想着买一把吉他来学学，说不定以后遇到bug解决不出来的时候弹弹吉他就能有解决思路了呢，于是就买了把吉他。然后呢，每天的生活就是早上上课，下课后看视频敲代码，中午吃饭，学一下吉他，下午上课，下课后回来看视频敲代码，下午吃饭，吃饭后学一下吉他，然后接着看视频敲代码，大概九点左右就去跑步，跑步回来弹一会吉他，然后就洗澡，接着看会视频，敲会代码~12点左右就睡觉了~大三下学期估计是我整个大学中最努力学东西的时候了，大三下学期的用脑量估计能占大学的百分之八十啊~~~~跟着视频把JavaSE的相关内容全部撸了一遍，然后吉他呢也学会了弹几首歌曲，虽然都没有一首是能完整无误的弹出来，但是开心就好嘛(⊙o⊙)…纵观大三这一年虽然看似没什么遗憾，但其实还是有的，就是整个宿舍基本上都有女朋友了，几乎就差我了(⊙o⊙)………. 大四由于大三想去的培训机构到后面才来宣传，而且要等到大四开学后的两个月才开始开班，加上自己把JavaSE部分的东西已经学完了，所以又开始由于要不要去培训了，然后大三的暑假就继续把JavaEE部分的东西和一些框架给学了。大四开学，学校只给我们专业开了一门课程，不过学校还不给我们出去实习，11月份才能出去。大四后宿舍有两条友已经出去培训了，只剩下6条咸鱼在学校继续享受大学最后的时光~因为大四没什么课程，所以就趁着这时间也跟着视频做了点项目，做完后感觉也不是很难嘛~所以就打消了去培训的想法，等学校这边课程结束就直接去找实习了，找实习也还算顺利吧，主要是觉得有人要我就去了，也没想这么多。找实习的过程-&gt;关于实习的 。整个实习过程也还算顺利，刚开始进公司实习的时候觉得很多东西都跟之前接触的不一样，所以刚开始还是蛮吃力的，不过后面慢慢熟悉套路后就相对比较简单了。整个实习过程还算好吧，第一次自己租房子住，平时上班回去后自己买菜煮饭，吃完后玩会手机，玩一下吉他，然后在去跑个步，回来洗个澡基本上一天也就这结束了，周末偶尔去我小姨那蹭个饭吃，偶尔也有同在南宁实习的舍友我这来开个小灶~~有时候也觉得平时上班有点累，周末就哪也不想去，就躺尸两天(⊙o⊙)…实习过程中让我比较感到骄傲的是，第一个月发工资的时候，老板说我得到了主管的认可，被认可的感觉真好啊，就像给我发了两个月工资一样兴奋，毕竟自己也算学渣一个了，自己工作中也没做什么大贡献吧，可能也是老板鼓励员工的一种方式吧，不过这种感觉还是很棒的。实习到四月中旬吧，因为实习的时候毕设都没怎么弄，不是没时间，而是有时候自己也在偷懒吧，然后就辞职了。然后接着就是回学校参加毕业答辩，写论文，改论文了，答辩过后各种聚餐各种浪了~毕竟这也是最后的学生时光了。说到大四有什么遗憾呢，大概就是这一年来都把相机冷落在一边了吧，导致到毕业的时候相机也出了点小故障，对相机的使用也是很陌生。所以毕业照也没拍几张。 总结流水账一写咋一看也8000多字了，写了一堆废话，越写到后面就越没什么激情写了，全当是简单的记录一下把,同时也很感谢这四年来认识的人，让我的大学有了更多的趣味吧。我的大学四年算不上太平淡，也算不上有多么的精彩，总之结束了就结束了，有再多的遗憾也不可能在弥补回来了，好好珍惜当下吧。毕业了，还是很迷茫，毕竟觉得自己也不是很适合敲代码，能在敲代码的这条路上走多久还是个未知数，曾经也向往过北上广，但是后面想想去了北上广也许自己能在技术方面能得到比较大的提升，但是也就有可能也会失去很多东西，有得必有失，人生常态，既然选择了就要学会认真的面对。毕业了，但并不是学习的终点，这辈子不学习是不可能的了，不学习就真的跟咸鱼没有什么区别了，之前实习做了很多计划吧，但是后面基本没怎么实现。但是一篇总结总得有个计划吧，要不然跟没写又有什么区别。未来计划：保持学习，保持总结，保持年轻，保持热泪盈眶~~~ 仅以此文，记录我已经逝去的大学生活~","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://52moyong.top/tags/随笔/"}]},{"title":"一致性哈希","slug":"一致性哈希","date":"2018-05-27T15:11:12.000Z","updated":"2018-06-03T16:19:50.310Z","comments":true,"path":"2018/05/27/一致性哈希/","link":"","permalink":"http://52moyong.top/2018/05/27/一致性哈希/","excerpt":"","text":"前言前面的文章已经介绍了哈希函数和哈希表特点，同时还介绍了哈希函数实现分流的效果，但是这种分流方式还是有缺陷的，而解决这种缺陷的方法正是使用一致性哈希进行解决的。一致性哈希算法在1997年由麻省理工学院提出，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简单哈希算法带来的问题，使得DHT可以在P2P环境中真正得到应用，这段摘抄至百度，具体一致性哈希是什么往下看就知道了。 一致性哈希的解决方案上一篇文章中我们使用的哈希函数解决分流问题在增加服务器和减少服务器的时候会存在一定的缺陷，即当我们要增加或减少服务器的时候就需要对所有的数据进行重新进行哈希函数的计算在对增加或减少后的服务器数量进行取模操作，然后在重新的将数据进行分配到各个服务器中，这样带来的数据迁移太大了，所以需要更好的解决方案来进行解决。而解决这个问题的方案就是一致性哈希算法。我们可以假设哈希函数计算出来的的值得范围为0-2^64，然后把这些哈希值看成一个环，然后在把所有机器的ip地址（或者mac地址，只要是能区分机器的就可以）通过同一个hash函数计算出他们的值，而这些值肯定也是在0-2^64，此时我们要添加数据时先把该数据经过哈希函数计算出的结果直接对应到环上的位置（这里前面哈希函数实现分流 不同，不需要在把算出来的哈希值模上机器数了），然后在从改位置按照环顺时针查找找到离它最近的机器，然后就把数据存到该位置上，具体过程如图所示：这里的关键实现是如何顺时针找到离它最近的机器，我们可以这么做，将所有机器的ip算出来的哈希值，组成一个数组，然后在对这个数组的元素进行升序排序。当来一个请求插入数据时，先算出该值得哈希值，然后采用二分方式，找到从左到右第一个大于等于它的值，该值就是所要找到的机器了，过程如下图所示：以上基本上就是一致性哈希的方式进行分流操作的实现了，下面就看看一致性哈希的方式对增加机器后数据迁移量有多大，如图所示：虽然上面以及能解决新增机器的数据迁移量减少了，但是还是存在一个比较严重的问题，那就是机器少的时候会出现负载不均衡的情况，如下所示：从上图来看已经达不到我们想要的负载均衡效果，这是由于机器数量太少，所以经过哈希函数计算后并不能均匀的分布，此时我们就需要增加机器节点的数量，但这里并不是真正的加一大堆机器，而是引入了虚拟节点的技术来帮助我们解决这个问题.","categories":[],"tags":[{"name":"-一致性哈希","slug":"一致性哈希","permalink":"http://52moyong.top/tags/一致性哈希/"}]},{"title":"哈希函数和哈希表","slug":"哈希函数和哈希表","date":"2018-05-24T15:11:12.000Z","updated":"2018-06-03T16:25:41.362Z","comments":true,"path":"2018/05/24/哈希函数和哈希表/","link":"","permalink":"http://52moyong.top/2018/05/24/哈希函数和哈希表/","excerpt":"","text":"前言前面介绍的线性表和树这两种数据结构中，插入的记录的相对位置一般是随机的，即和记录的关键字之间不存在确定的关系，想要查找相关的记录需要进行比较，查找的效率依赖于查找过程中的比较次数。而我们理想的状态是能够直接查找到所记录的值，所以就需要对查找的值和它的存储位置建立一个对应的关系f,使每个值都对应着一个存储位置。 哈希函数哈希函数，既然是函数那么就会有输入和输出，同时作为一个函数又会有它自己的一些性质，而经典的哈希函数有一下特点：1.哈希函数的输入域是无穷大的2.哈希函数的输出域是有穷尽的3.当输入域是固定的时候，输出域也是固定的。4.当输入域不一样的时候，有可能得到一样的值（哈希冲突或者碰撞）。5.当输入域的样本容量很大的时候，输出域是成均匀分布的（非常重要的性质）。对于第一点很好理解，比如一个函数我们接受的是一个String类型的数据那么我们就能传入的参数将是无穷个的，而第二点也是很好理解，即我们函数的输出结果的数量是固定的，是有一个范围值的，比如1-10000。无论输入什么数据都会返回这个1-10000内的数值。对于第三点，即我们输入同一个值，那么得到的输出结果是一样的，比如第一次输入1，第二次还是输入1，两次得到的结果是一样的。第四点结合上面三点的性质也不难，既然输入域是无穷大的，而输出域的结果是固定的，那么当有很多输入的样本量大于输出的结果时，必然会有不同的输入得到一样的输出结果。对于第五个性质可能比较难理解，如下图所示： 哈希表哈希表中的元素是由哈希函数确定的，即hash函数算出来的值作为该元素在 hash表中的存储位置。经典哈希表的实现如下图所示：上面是经典hash表的实现，而在java中的hash表的实现是对产生冲突的值形成的是红黑树，而不是链表。 作用哈希函数的是一个十分重要的东西，因为它的增删改查的效率可以到达O(1)，在大数据的处理上表现的十分好。同时还能对信息进行加密处理，如MD5。以及对服务器分流操作等，下面就来看看hash函数是怎么对服务器进行分流，达到负载均衡的效果。实现过程如下图所示：以上就是经典的哈希函数实现服务器分流的效果，但是这还是有缺陷的，比如我们要实现增加服务器和减少就会有一定的问题，这个问题在下篇文章继续学习。 总结由于哈希函数实现的过程比较复杂，而且实现的方式也有很多种，这里就不给出具体实现了，我们只要记住哈希函数的这些特性就可以了。","categories":[],"tags":[{"name":"-哈希函数 -哈希表","slug":"哈希函数-哈希表","permalink":"http://52moyong.top/tags/哈希函数-哈希表/"}]},{"title":"小白学数据结构--AVL树","slug":"小白学数据结构（三 )","date":"2018-05-16T15:11:12.000Z","updated":"2018-06-03T16:26:11.908Z","comments":true,"path":"2018/05/16/小白学数据结构（三 )/","link":"","permalink":"http://52moyong.top/2018/05/16/小白学数据结构（三 )/","excerpt":"","text":"前言前面我们介绍了平衡二叉树和二叉搜索树在查找的时候可能会出现效率不高的情况。而我们现在要学习的是带有平衡性的搜索二叉树—AVL树。AVL树是最先发明的自平衡二叉搜索树。和平衡二叉树一样，AVL树中任何节点的两个子树的高度最大差别为一。所以说AVL树是一颗严格的平衡二叉树树。 AVL树的旋转根据上面我们认识的AVL树，我们可以很容易的识别出是不是AVL树,如下图所示：如果我们对AVL树进行插入数值，那么AVL树又是怎么保证它的特性呢，这时就可以通过旋转操作来保持AVL树的特性。AVL树本身就是就是一颗二叉搜索树，所在在插入数据的时候，需要按照二叉搜索树的规则来进行插入数据，此时就有可能出现上一篇文章的结尾中，出现左右子树可能恶化成线性树，破坏平衡性，因此我们旋转的目的就是为了降低树的高度来保持树的平衡。而我们的旋转可以分为左旋和右旋：1.右旋：b是a的左子树。那么当该树被平衡性被破坏时，我们将b围绕着a向右旋转（按照二叉搜索树的规则a节点一定比左子树的节点都大）所以a就被旋转成b的右子树。2.左旋：b是a的右子树。那么当该树被平衡性被破坏时，我们将b围绕着a向左旋转（按照二叉搜索树的规则a节点一定比右子树的节点都小）所以a就被旋转成b的左子树。插入数据导致不平衡又可以分为四种情况：LL型，RR型，LR型，RL型。前两种属于单旋转，后两种则属于双旋转。 LL右旋转LL型，单旋转操作，LL型是由于插入左子树的左节点导致左子树的左子树成线性排列导致不平衡，所以要对左左子树进行右旋操作,右旋转过程如下图所示： RR左旋转RR型，单旋转操作，RR型是由于插入右子树的右节点导致右子树的右子树成线性排列导致不平衡，所以要对右子树进行左旋操作,器旋转过程如下图所示： LR型左旋转，右旋转LR型，双旋转操作，LR型是由于插入左子树的右节点导致左子树的不平衡性，但是它并不是成线性排列，所以要对左子树进行两次旋转的操作，先进行左旋转操作，使其变成左子树的线性排列，然后在进行右旋转操作使其变成平衡，LR型旋转如下图所示： RL型右旋转，左旋转RL型，双旋转操作，RL型是由于插入右子树的左节点导致右子树的不平衡性，但是它并不是成线性排列，所以要对右子树进行两次旋转的操作，先进行右旋转操作，使其变成右子树的线性排列，然后在进行左旋转操作使其变成平衡，LR型旋转如下图所示： 总结本文主要介绍了AVL树的特点，以及AVL树在插入节点时是如何保持平衡的，由于代码的实现是比较复杂的所以本文并不打算对代码进行实现，我们只需要了解其特性就可以了。","categories":[],"tags":[{"name":"-数据结构 -AVL树","slug":"数据结构-AVL树","permalink":"http://52moyong.top/tags/数据结构-AVL树/"}]},{"title":"小白学数据结构--二叉树","slug":"小白学数据结构（二 )","date":"2018-05-11T12:56:54.000Z","updated":"2018-05-30T03:03:16.369Z","comments":true,"path":"2018/05/11/小白学数据结构（二 )/","link":"","permalink":"http://52moyong.top/2018/05/11/小白学数据结构（二 )/","excerpt":"","text":"前言前面的介绍线性表的时候说过数据结构分为四大类型，而本文将要介绍的是树形结构。树是一种很重要的数据结构，树形结构在我们实际运用中很常见，比如操作系统的目录就是树形结构。本文主要以树形结构中比较常见的二叉树来进行学习。二叉树，每个节点最多有两个子树结构，节点的左边节点成为左节点，左节点形成的树成为左子树。同理节点的右边节点称为右节点，右节点形成的树成为右子树。更多二叉树的介绍详见百度百科。本文主要学习二叉树中比较常用的类型：平衡二叉树和二叉搜索树。 二叉树的遍历在学习平衡二叉树和二叉搜索树之前，我们先来学习一下二叉树的遍历。二叉树的遍历主要有先序遍历，中序遍历，后续遍历，按层遍历。下面依次讲解。 先序遍历先序遍历的主要思路是先遍历当前节点（一般是根节点），在遍历左子树，最后遍历右子树，即根左右，如下图所示： 中序遍历中序遍历主要思路是先遍历左子树，在遍历根节点，最后遍历右子树，即左根右，如图所示： 后序遍历中序遍历主要思路是先遍历左子树，在遍历右子树，最后遍历根节点，即左右根，如图所示： 平衡二叉树平衡二叉树主要的特点是它的左右两个子树的高度差不超过1，并且左右两子树都是一颗平衡二叉树。根据平衡二叉树的特点，我们要判断二叉树是否是平衡二叉树我们需要知道一下条件：1.左子树是否平衡2.右子树是否平衡3.左子树的高度4.右子树的高度只要满足作1.2的条件，在满足左子树高度与右子树高度不超过1，就是平衡二叉树。判断是否是平衡二叉树的过程如下：由上述过程可知，我们要用代码实现上述过程，判断是否是平衡二叉树就需要两个返回值。1.子树是否平衡2.子树的高度。因此我们的代码实现如下： public class IsBalancedTree { //定义一个判断是否时平衡二叉树的返回值 public static class ReturnData{ public boolean isB;//是否是平衡二叉树 public int hight;//子树高度 public ReturnData(boolean isB,int hight){ this.isB=isB; this.hight=hight; } } //一颗树的节点。持有指向左右子节点的引用 public static class Node { public int value; public Node left; public Node right; public Node(int data) { this.value = data; } } public static ReturnData process(Node root){ if(root==null){//空树也是平衡二叉树 return new ReturnData(true, 0); } ReturnData leftTree = process(root.left);//拿到左树去判断是否时平衡二叉树 if(!leftTree.isB){ //如果左树不是平衡二叉树了，那么整棵树就不是平衡二叉树了，高度自然也不重要了 return new ReturnData(false, 0); } ReturnData rightTree = process(root.right);//拿到右树去判断是否时平衡二叉树 if(!rightTree.isB){ //如果右树不是平衡二叉树了，那么整棵树就不是平衡二叉树了，高度自然也不重要了 return new ReturnData(false, 0); } //左右子树都是平衡，还需满足其左右子树高度差小于1 if(Math.abs(leftTree.hight-rightTree.hight)&gt;1){ //高度差大于1，那么整棵树就不是平衡二叉树了，高度自然也不重要了 return new ReturnData(false, 0); } //以上条件都满足那么就是平衡二叉树，并且要返回树的高度 return new ReturnData(true, 0); } public static boolean isBalanced(Node node){ ReturnData result = process(node); return result.isB; } public static void main(String[] args) { Node node = new Node(5); node.left=new Node(2); node.right=new Node(1); node.left.left=new Node(4); System.out.println(isBalanced(node)); } } 二叉搜索树二叉搜索树它要么是一颗空树，要么有以下特点:若一颗树的左子树不为空，那么其左子树的所有节点都小于根节点，若一颗树的右子树不为空，那么其右子树的所有节点都大于根节点。同时他们的左右子树必须是二叉搜索树。下图则为典型的二叉搜索树：而我们该怎么去判断一颗树是都是二叉搜索树呢，其实方法很多，这里主要选取一种比较简单的方法，用到了我们上面二叉树遍历的中序遍历来解决这个问题。二叉搜索树 还有一个重要的结论就是在使用中序遍历二叉搜索树的结果中会得到一个升序的序列。即遍历出来的数据是按照升序进行 排列的。因此我们只需要在遍历的时候与上一个数进行比较，如果都是大于上个数，那么该二叉树就是二叉搜索树。代码实现如下： public class IsBST { //一颗树的节点。持有指向左右子节点的引用 public static class Node { public int value; public Node left; public Node right; public Node(int data) { this.value = data; } } public static boolean isBST(Node head) { int temp=Integer.MIN_VALUE;//临时记录上一个节点的值,y一开始 为系统最小值 if (head != null) { Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while (!stack.isEmpty() || head != null) { if (head != null) { stack.push(head); head = head.left; } else { head = stack.pop(); if(head.value&gt;temp){ temp=head.value; }else{ return false; } head = head.right; } } } return true; } public static void main(String[] args) { Node node = new Node(5); node.left=new Node(3); node.right=new Node(8); node.left.left=new Node(1); node.left.right=new Node(4); node.right.left=new Node(6); node.right.right=new Node(9); System.out.println(isBST(node)); } } 总结平衡树虽然在一定程度上能够限制了树的高度，但是它进行查找某个元素的时候还是需要遍历整棵树，效率不是很高，而二叉搜索树由于它根节点都比左子树大，而比右子树小的特点，我们每次进行查找都能过滤掉一半的数，有点类似于二分查找的算法，但是也会有极端的情况出现。比如下图所示：这时候我们就想，如果二叉搜索树能够变成平衡树，那么是不是就能有更好的效率了呢，所以就有了平衡二叉搜索树，这种树的实现有：有红黑树、AVL、替罪羊树、Treap、伸展树等，下次我们将要学习前两种红黑树和AVL树。","categories":[],"tags":[{"name":"-数据结构 -二叉树","slug":"数据结构-二叉树","permalink":"http://52moyong.top/tags/数据结构-二叉树/"}]},{"title":"小白学数据结构--线性表","slug":"小白学数据结构（一 )","date":"2018-05-08T14:38:54.000Z","updated":"2018-05-28T06:28:04.130Z","comments":true,"path":"2018/05/08/小白学数据结构（一 )/","link":"","permalink":"http://52moyong.top/2018/05/08/小白学数据结构（一 )/","excerpt":"","text":"前言数据结构是计算机存储，组织数据的方式，精心设计的数据结构可以带来更高的运行效率或者存储效率。而数据结构主要研究的是数据的逻辑结构，和物理结构。逻辑结构反应的是数据之前的前后关系，与计算机中的存储位置无关。物理结构就是指数据在计算机存储空间中的位置。逻辑结构主要又分为集合，线性结构，树形结构，图形结构。而本文所讲的线性表属于线性结构，线性结构是指数据是按照线性排列的。线性表是最简单数据结构，但是也是非常常用的数据结构，线性表主要又分为两大类：顺序表和链表。下面我们以一支足球队入住酒店的例子来讲解这两种结构。 顺序表顺序表是指在逻辑结构上连续的数据，在物理结构上也是连续的。例如：一支足球队他们的球衣是1-11号连续的号码（逻辑结构连续）。入住一家酒店，酒店的房间号为0-10，而1号球员入住的是0号房间，2号球员入住的是1号房间，3号球员入住的是2号房间，以此类推1-11号球服的球员们都是按照球衣的顺序入住顺序的房间。因此我们能够很快的知道哪个房间住的是哪个球员。如下图所示：这个结构是不是很熟悉，其实就是我们经常见到的数据结构，在java中我们的ArrayList底层就是数组的实现的，所以Java中顺序表的提现就是ArrayList。具体实现可参考文章：ArrayList初始化 链表链表是指在逻辑结构上连续的数据，但是物理结构是不一定连续的。例如：我们都知道，一支11人的足球队入住酒店，一般是不可能找到连续的房间能够入住的。这时我们想要找到一个球员是住在哪个房间就不容易了（物理结构不连续）。 单链表这个时候我们就需要让1号球员记住2号球员所住的房间，2号球员记住3号球员所住的房间，以此类推，每个球员要记住下一个球员的房间，保证他们在逻辑上是连续的。这就是单链表的体现。如下图所示： 双链表双链表，是在单链表的基础在增加了一个指向前一个节点的引用，即在球队中当前球员不仅要记住下一个球员的房间号，还要记住前一个球员的房间号，例如5号球员不仅要记住6号球员的房间号，还要记住4号球员的房间号，增加一个引用去记录前一个球员的房间号，那么久能更快得查找到某个球员的房间号了，这就是典型的空间换时间的算法。双链表如图所示：在Java中我们的LinkList底层的实现就是双链表的结构，具体的实现可参考文章：LinkedList初探 小结以上就是对线性表中的两种结构进行描述说明，当然还有两种比较特殊的线性表：栈和队列，他们属于受限的线性表，本文就不加以描述。数据结构是一个比较重要的知识点，了解好数据在计算机内存中的存储结构，才能帮助我们设计出更好的算法。","categories":[],"tags":[{"name":"-数据结构 -线性表","slug":"数据结构-线性表","permalink":"http://52moyong.top/tags/数据结构-线性表/"}]},{"title":"堆排序","slug":"堆排序","date":"2018-05-04T14:39:40.000Z","updated":"2018-05-12T06:52:29.720Z","comments":true,"path":"2018/05/04/堆排序/","link":"","permalink":"http://52moyong.top/2018/05/04/堆排序/","excerpt":"","text":"前言堆是一种很重要的数据结构，堆结构其实是颗完全二叉树。我们所说的优先级队列其实也就是堆结构，所以说堆结构在在很多地方都扮演着很重要的角色，前面的分治算法中已经介绍了快速排序和归并排序两个重要的排序算法，本文在继续补充一个同样很重要的排序算法–堆排序 堆排序堆是一种完全二叉树的结构，是一种非常重要的数据结构。完全二叉树，完全二叉树主要有两种类型，一种是满二叉树，即除了最后一层外所有的叶子节点都是满的，每个父节点都有左右两个子节点。还有一种情况是，最后一颗二叉树除了最后一层以外节点数都达到最大个数，最后一层的所有节点都连续集中在最左边。堆又可以分为大根堆和小根堆，大根堆是每个节点的值大于左右子节点的值，小根堆是每个子节点的值小于左右子节点的值。 大根堆的根节点一定是整棵树的最大值，小根堆的根节点一定是整颗树的最小值，所以堆排序的主要思路是构造大根堆后把根节点和数组最后一个数交换位置，然后除去数组最后一个数在继续构建大根堆，此时根节点就是当前构造大根堆中的最大值（同时也是整个数组的第二大值），然后把根节点和当前构造大根堆的数组的最后一只数进行交换。重复上诉操作指导只剩下根节点即可得到最后的排序结果堆排序的主要步骤为：1.将数组根据公式构造出一个完全二叉树2.将完全二叉树转换成大根堆（升序构建大根堆，降序构建小根堆）3.将大根堆的根节点和当前构造大根堆的数组的最后一个数交换位置4.除去交换后的数组的最后一个数继续构造大根堆重复3步骤5.直到只剩根节点，即可得到有序数组以下就是堆排序的过程：堆排序代码实现如下： public class HeapSort { public static void heapSort(int[] arr) { if (arr == null || arr.length &lt; 2) { return; } for (int i = 0; i &lt; arr.length; i++) { heapInsert(arr, i); } int size = arr.length; //得到大根堆后和最后一个数交换 swap(arr, 0, --size); while (size &gt; 0) {//size是每次交换完位置后除去最后一个数后所剩下的数组长度 heapify(arr, 0, size); swap(arr, 0, --size); } } //构建大根堆 public static void heapInsert(int[] arr, int index) { while (arr[index] &gt; arr[(index - 1) / 2]) { swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; } } public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void heapify(int[] arr, int index, int size) { int left = index * 2 + 1; int right=index*2+2; while (left &lt; size) {//保证左子节点位置数组不越界，即保证一定存在左子节点才能操作 //首先要保证右节点存在，才和左节点的值进行比较，左右节点选出最大值和根节点比较 int largest = right &lt; size &amp;&amp; arr[right] &gt; arr[left] ? right : left; largest = arr[largest] &gt; arr[index] ? largest : index; //如果交换后的根节点依然比左右节点大则不用进行交换操作 if (largest == index) { break; } swap(arr, largest, index); index = largest; left = index * 2 + 1; } } public static void main(String[] args) { int [] arr={3,2,6,4,5,2,4,1}; heapSort(arr); System.out.println(Arrays.toString(arr)); } } 小结由于堆排序不需要大量的递归或者而外的需要辅助数组，所以堆排序非常适合数据量很大的场景（百万级），和之前的快速排序和归并排序对比，如果是在百万级的数据的时候，由于快速排序和归并排序都使用递归的算法设计，在数据量很大的情况下就有可能会出现堆栈溢出。","categories":[],"tags":[{"name":"-算法 -堆","slug":"算法-堆","permalink":"http://52moyong.top/tags/算法-堆/"}]},{"title":"小白学算法--分治算法","slug":"小白学数据结构和算法（一）","date":"2018-05-02T13:59:44.000Z","updated":"2018-05-12T03:28:44.214Z","comments":true,"path":"2018/05/02/小白学数据结构和算法（一）/","link":"","permalink":"http://52moyong.top/2018/05/02/小白学数据结构和算法（一）/","excerpt":"","text":"前言程序=数据结构+算法，虽然还是不太能领悟这个这个结论的意思。但是听很多前辈说数据结构和算法是程序员的内功心法，所以对数据结构和算法小白的我，要慢慢的修炼这门内功心法，慢慢向大白靠拢~~~ 分治算法概述分治算法的思想是当我们遇到一个规模为N的大问题时可以分解成若干个K规模的小问题进行解决，这些小问题需要解决的问题与规模为N的问题性质是一样的，但是又是相互独立的，通过一个个小问题不断的解决后在不断的组合成最终解决大问题的过程。即分而治之的过程。而这里主要是通过基础的排序算法来学习分治算法的思想。排序算法有很多种，冒泡，插入，选择，归并，快速排序，堆排序等等，就主要选取体现分治思想的两个排序算法来学习，归并和快排（注：并不是只有这两个排序算法才是体现分治思想） 归并排序归并排序的主要思路是将一堆无序的数分为按照中间索引分解成左右两部分，先对左右两部分进行排序使左右两部分有序，再对左右两部分进行合并进行比较排序，这是总的思路。而左右两边的排序也是和总的思路一样，先拆分后合并，最后是不断的往下拆分成一个个数，最后在不断的往上合并得到一个有序数。而合并的过程是将左右两边的数各自从各自左边的数开始进行比较，小的就放到一放到一个准备好的辅助数组里面，然后小的数指针将往前移动继续和另一边的数进行比较。最后在把辅组数组的数依次填充到原数组中。下图为归并排序的过程图：具体代码实现如下： public class MergeSort { public static void mergesort(int [] arr){ //如果是null或者是1个数就没有比的必要 if(arr==null || arr.length&lt;2){ return; } //拆分 mergesort(arr,0,arr.length-1);//数组最左边索引和最右边的索引 } //递归拆分 public static void mergesort(int [] arr,int l,int r){ if(r==l){//如果最左边和最右边的索引值一样说明只剩一个数了，就不需要继续拆分 return; } int mid=(r+l)/2;//中间索引 mergesort(arr,l,mid);//左边部分继续拆分 mergesort(arr,mid+1,r);//右边部分继续拆分 merge(arr,l,mid,r);//合并 } //合并的过程 public static void merge(int [] arr,int l,int m,int r){ int[] help=new int[r-l+1];//初始化一个辅助数组长度为要合并的两个数组的长度 int i=0; int L=l;//左边部分初始位置的指针 int R=m+1;//右边初始位置的指针 //循环比较左右两边的数小的数放到辅助数组中， //循环结束的标志是左边部分或者右边部分的数都取完，然后把没取完的部分直接加入辅助中 while(L&lt;=m &amp;&amp; R&lt;=r){ help[i++]=arr[L]&lt;arr[R]?arr[L++]:arr[R++]; } //左右两部分循环结束后，必定会其中一部分会有剩余，剩余部分直接加入辅助数组 while(L&lt;=m){//说明是左边部分剩余 help[i++]=arr[L++]; } while( R&lt;=r){//说明是右边部分剩余 help[i++]=arr[R++]; } //把每一部分合并后的数组对应的每个值填充到原数组中，最后就得到一个有序数组 for (i = 0; i &lt; help.length; i++) { arr[l + i] = help[i]; } } public static void main(String[] args) { int arr[]={5,2,3,6,1,4}; mergesort(arr); System.out.println(Arrays.toString(arr)); } 快速排序快速排序的基本思路是将一堆需要排序的数据从中取一个数（经典快排取的是最后一位，随机快排是随机取一个数然后与最后一位数交换位置）来对整个数据进行比较，比选出的数小的放左边，比选出的数大的数放右边，等于选出的数放中间，即划分成三个部分（也可以划分两部分小于等于选出的数的放左边，大于放右边）然后在按此方法对左右两边的数据进行同样的操作，从而达到整个数据为有序状态。快排的基本步骤是1.准备数组的左右指针L,R（数组索引的左右边界下标值）2.准备两个左右边界以外的两个指针，x=L-1,y=R+1 ,3.取数组的最后一位数最为对比数 ，4.比较的过程为，从L指针开始，如果L指针上的数小于对比数，x指针向前移动一位，移动后的数与L指针上的数进行交换位置，L指针再继续往前移动，如果L指针上的数大于对比数，那么Y指针向后移动一步，并且与L指针上的数交换位置，L指针不移动，在继续与对比数进行比较。如果L指针上的数等于对比数，那么不做交换，只需要把L指针往前移动一步。5.把一轮排序过后的等于值的左右边界指针（索引）返回，然后在把小于对比数的左边部分（范围为：L到等于值左索引-1），大于对比数的右边部分（范围为：等于值右索引+1到R）继续重复上述过程以下是快排实现过程图：具体代码实现过程如下所示： public class QuickSort { public static void quickSort(int[] arr){ if (arr == null || arr.length &lt; 2) { return; } quickSort(arr, 0, arr.length - 1); } public static void quickSort(int[] arr, int l, int r){ if(l&lt;r){//递归的条件是左边索引小于右边索引，如果是等于了就说明只剩一个数了 //不加这句话就是直接使用数组的最后一个数作为比较数，即经典快排，加上后就是随机快排 swap(arr, l + (int) (Math.random() * (r - l + 1)), r); int[] p = partition(arr, l, r);//得到一个中间部分的等于值得左右边界索引值 quickSort(arr, l, p[0] - 1);//左边部分继续递归操作 quickSort(arr, p[1] + 1, r);//右边继续递归操作 } } //与对比数对比的过程 public static int[] partition(int[] arr, int l, int r) { int x = l - 1; int y = r + 1; int num=arr[r];//对比数 while (l &lt; y) { if (arr[l] &lt; num) { swap(arr, ++x, l++); } else if (arr[l] &gt; num) { swap(arr, --y, l); } else { l++; } } return new int[] { x + 1, y - 1 }; } //交互数组的两个数的位置 public static void swap(int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } public static void main(String[] args) { int [] arr={3,2,6,4,5,4}; quickSort(arr); System.out.println(Arrays.toString(arr)); } } 总结以上两种排序算法实现的过程都不一样，但是总体上解决问题的思路是一致的，都是将一个大问题分解成若干个小问题进行求解，而这些小问题的性质根大问题都是一样的，因此解决每一个小问题后在进行合并成大问题进行解决最终能求出我们的最终解，（这里使用的是递归的方式实现对每个问题的求解，递归的实质就是系统将方法压栈的过程，实际运用并不会使用递归，一般会自己实现一个栈，然后自己控制方法的压栈）这就是分治算法的体现。作为一个小白学习算法是一个痛苦的过程，因为在学习的过程中，可能并不会有很明显的进步，算法是需要不断的积累，慢慢的修炼才能提高解决问题的能力。所以一定要坚持学习！！！","categories":[],"tags":[{"name":"-算法 -分治","slug":"算法-分治","permalink":"http://52moyong.top/tags/算法-分治/"}]},{"title":"实习时记的一些笔记","slug":"实习笔记","date":"2018-04-18T13:59:44.000Z","updated":"2018-05-10T08:32:45.080Z","comments":true,"path":"2018/04/18/实习笔记/","link":"","permalink":"http://52moyong.top/2018/04/18/实习笔记/","excerpt":"","text":"前言刚去公司实习的时候，还是比较勤奋的，遇到很多好的解决方案都会记下来，虽然都是很简单的东西，但是对自己帮助还是很大的，但是由于后面还是太懒了，所以记的笔记也不是很多，还是希望以后自己能多勤奋点记笔记把 笔记内容1.当下拉框不是select时，而是使用ul，li的时候无法将name和value作为参数给表单提交，这时候可以使用一个隐藏域input作为当前想要提交的数据，通过选择时（单击事件等）把所要的值设置到value中即可。2.this关键字。如果父类方法中有this的引用，如果是父类实例化后调用该方法，那么this指的是父类的实例，如果是子类实例化后调用该方法，那么指的是子类实例，既，哪个实例对象调用该方法就指的是谁的实例。3.struts做国际化的时候中文配置文件输入中文需要把编码格式改成iso-8859-1,这样在读取中文内容的时候就不会出现乱码。4.当for循环里面有需要根据id等条件去查询数据库的时候，为了避免for循环次数产生多次查询数据库，可以先把所有数据查出来放到一个map里面，key为id(或者要查找的条件)，value为当前条件查出来的值，或者for循环里你想要的查找的值。5.一个方法返回得到两个数据可以使用引用传递。比如new 两个对象，把这两个对象放到方法中作为参数，执行这个方法后就可以得到改变后的这两个对象的内容数据。6.通过定义一个boolean类型的全局变量（常量），然后进行判断用来切换新旧方法的实现。7.可以使用函数重载（增加参数）。然后调用原来的方法来对方法进行扩展。8.策略模式就是用来封装变化（算法）的，提供一个策略接口，不同的策略算法都实现这个接口，同时用一个工厂来生成不同的策略，生成策略的方法可以用反射，这样就不会因为新加策略而改动工厂。即抽象工厂+策略模式实现了减少类与类之间的耦合（依赖）。9.遮罩层关闭之前调用此函数function reload(){ $(“.reload_btn”,parent.document).trigger(‘click’); }背景层：重新加载页面 不做任何事情，只是定义一个属性$(“.reload_btn”).click(function(){ location.reload(); });这样就可以实现遮罩层修改数据后，背景层能同步上。10.json中对于{“字段”：null}这样的key,value键值对是不显示的，会隐藏掉。这时我们就需要用到fastjson的SerializerFeature序列化属性也就是这个方法：JSONObject.toJSONString(Object object, SerializerFeature… features)11.clazz.getDeclaredFields();只能获取本类的所有字段，不能获取父类的字段。12.获取数据库的数据时，如果要查全部，一定要谨慎，看看是不是有其他方案可以解决，尽量不要查全部，因为数据多了会有性能问题。13.一些小细节：显示问题待审核—》编辑审核过—》查看 sql语句：in() 集合要记得判断空，size是否等于0not in ()要谨慎，几乎是查询全部，要考虑数据量 一些不可逆的操作一定要再次弹框提示，比如删除，填写意见后不可以更改等。","categories":[],"tags":[{"name":"-随笔 -笔记","slug":"随笔-笔记","permalink":"http://52moyong.top/tags/随笔-笔记/"}]},{"title":"java nio初探","slug":"java-nio初探","date":"2018-01-26T13:22:46.000Z","updated":"2018-05-10T07:13:38.004Z","comments":true,"path":"2018/01/26/java-nio初探/","link":"","permalink":"http://52moyong.top/2018/01/26/java-nio初探/","excerpt":"背景在公司实习已经有一段时间了，刚开始的时候还是比较兴奋的，因为终于可以真正的做项目啦，但是过了段时间又觉得好像没啥太大进步，毕竟给的需求都比较简单，实现起来还是比较轻松，虽然还是花了比较长的时间（只能怪自己基础不是很牢），但是慢慢的也适应了，就觉得没学到啥新东西，还是挺遗憾的，直到最近主管给我安排了个需求，是实现和硬件通信的，然后给我讲这个项目的整体流程，是基于socket通信的东西，当时跟我讲了一大堆，客户端发起一个长连接，然后通过通道进行数据传输…讲了一大堆我是一脸懵逼啊，然后就叫我自己先看，不懂再问他。看了一下发现好多类都没见过，然后就去百度，发现是nio包下的，哈哈，激动+1，，然后在往下看看，发现ConcurrentHashMap,哈哈，这不是那个很吊的并发容器么。激动+2，再看看发现线程池，哈哈，激动+3，都是之前没接触过的东西，终于能接触到新知识啦~所以就有了这篇学习笔记，ok,不逼逼了。往下看~~","text":"背景在公司实习已经有一段时间了，刚开始的时候还是比较兴奋的，因为终于可以真正的做项目啦，但是过了段时间又觉得好像没啥太大进步，毕竟给的需求都比较简单，实现起来还是比较轻松，虽然还是花了比较长的时间（只能怪自己基础不是很牢），但是慢慢的也适应了，就觉得没学到啥新东西，还是挺遗憾的，直到最近主管给我安排了个需求，是实现和硬件通信的，然后给我讲这个项目的整体流程，是基于socket通信的东西，当时跟我讲了一大堆，客户端发起一个长连接，然后通过通道进行数据传输…讲了一大堆我是一脸懵逼啊，然后就叫我自己先看，不懂再问他。看了一下发现好多类都没见过，然后就去百度，发现是nio包下的，哈哈，激动+1，，然后在往下看看，发现ConcurrentHashMap,哈哈，这不是那个很吊的并发容器么。激动+2，再看看发现线程池，哈哈，激动+3，都是之前没接触过的东西，终于能接触到新知识啦~所以就有了这篇学习笔记，ok,不逼逼了。往下看~~ 传统的socket通信阻塞和非阻塞阻塞和非阻塞就是当我们的应用程序没有访问数据时数据还没有准备好的时候的一种处理方式。你去银行取钱，人很多你只能排队取钱。一直阻塞在那里等待什么事情都不能做，非阻塞就是你领了一张小票，拿着票排队，排队期间你还可以去做其它的事情而不用一直在排队的队伍里面等待，当到你的时候直接去取钱就可以了。而我们传统的socket通信就是阻塞式的通信方式。传统socket的通信代码 服务端： public class SocketServer { public final static int PORT = 8765; public static void main(String[] args) { ServerSocket serverSocket=null; BufferedReader in = null; // 记录连接次数 int count = 0; try { serverSocket = new ServerSocket(SocketServer.PORT); // 一直阻塞着，接收客户端的请求 count++; while (true) { Socket socket = serverSocket.accept(); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 对读到的数据进行处理,假设处理数据需要5s Thread.sleep(5000); System.out.println(&quot;客户端第&quot; + count + &quot;连接&quot;); System.out.println(&quot;需要对客户端发来的数据进行处理是：&quot; + in.readLine()); } } catch (Exception e) { e.printStackTrace(); }finally { if(in != null){ try { in.close(); } catch (Exception e1) { e1.printStackTrace(); } } if(serverSocket != null){ try { serverSocket.close(); } catch (Exception e1) { e1.printStackTrace(); } } } } } 客户端： public class SocketClient implements Runnable { public final static String ADDRESS = &quot;127.0.0.1&quot;; public final static int PORT = 8765; @Override public void run() { Socket socket = null; PrintWriter out = null; try { socket = new Socket(ADDRESS, PORT); out = new PrintWriter(socket.getOutputStream(), true); out.println(&quot;123&quot;); } catch (Exception e) { e.printStackTrace(); } finally { if (out != null) { try { out.close(); } catch (Exception e) { e.printStackTrace(); } } if (socket != null) { try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { new Thread(new SocketClient()).start(); ; } } } 从上面的代码可以看出当客户端发送数据给服务端的时候，服务端阻塞到客户端连接后进行读取数据，读取数据过程中如果数据还没有准备好（数据在传输过程中会受到网络带宽等影响），就会阻塞，阻塞过程中线程会失去cpu的使用权，假设读取数据后对数据进行操作处理需要一段时间假设5s，那么10个客户端连接进行数据处理将要50s，这在现代大规模的访问量来说是不能接受的，当然数据的处理我们可以采用多线程的方式来处理，即一个连接一个线程，出现阻塞时只是一个线程阻塞而不影响其他线程的工作，但是当大量连接到来时，使用多线程也会影响系统的开销，因为线程的创建和回收会增加系统的开销，同时线程的切换也是需要时间的，当然合理的使用线程池也就能够减少线程的创建带来的开销，但是这仍然没有能够解决读取数据过程中阻塞操作的问题，依然使用的是同步阻塞模型。 NIO带来的解决方案首先先总体看一下NIO的结构，NIO的工作方式主要是围绕着Selectors（选择器），Channels（支持异步读写的通道），Buffers（用于读写数据的缓冲区）这三个组件为核心所展开的。如下图： Channels传统的io是基于字节流和字符流进行操作的，也就是说是面向流的操作，这意味着进行读写操作的时候，如果数据还没有准备好，例如经过网络传输的数据，由于带宽延迟等各种因素，那么当前的线程只能一直阻塞在那里，不能做其他事情，而且传输的数据是没有被缓存在任何地方的，而NIO则是面向通道和缓存的，数据总是从通道读到缓冲区，或者从缓冲区写到通道。通道（Channels）有点类似传统io中的流（Steam）,但是流是单向的而，通道是双向的。通道主要有一下几种分类：1.FileChannel (文件io)2.DatagramChannel （udp网络io）3.SocketChannel (tcp网络id)4.ServerSocketChannel (监听tcp连接的网络io)主要介绍一下后面两个SocketChannel和ServerSocketChannel，他们的关系相当于传统io中的Socket和Serversocket，服务端通过获取ServerSocketChannel的实例（open()）然后进行阻塞（accept()）接收客户端的连接，客户端的一个新连接就会创建一个SocketChannel实例，然后就可以对这个通道进行操作。Selectors在了解Selectors之前，我们先简单的了解一下UNIX网络编程，在linux内核中会将所有的外部设备看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，然后返回一个文件描述符。根据UNIX网络编程对IO模型的分类，IO模型可以分为以下5种：1.阻塞IO模型2.非阻塞IO模型3.IO复用模型4.信号驱动模型5.异步IO模型下面简单的介绍下IO复用模型中的多路复用技术，NIO中的Selectors就是一种多路复用技术的实现：多路复用技术就是把多个阻塞的IO复用到一个select上进行阻塞，这样就能实现单个线程能够处理多个客户端的请求操作了。多路复用技术主要用于以下场景： 服务端需要同时处理多个处于监听状态或者多个连接的套接字 服务端需要同时处理多种网络协议的套接字 目前支持IO多路复用技术的系统调用有select,pselect,poll.epool,在linux中主要选择的是epool来做轮询操作，NIO中也是基于epool实现的多路复用技术，它有以下有点：1.支持一个进程打开文件描述符不受限制，仅限于操作系统的最大文件句柄数2.IO效率不会随着文件秒速符的数量的增加而线性下降3.使用mmap加速内核与用户空间的消息传递4.epool的API更加简单。以上只是对Linux中的一些知识点进行学习（摘抄于Netty权威指南），以便更好的理解NIO中的多路复用技术。 接下来回到我们的NIO的Selectors。选择器，这是NIO实现非阻塞的关键，它是基于事件驱动的，它会监听每一个注册在选择器上channels的IO事件,比如连接事件，接收事件，读事件和写事件。它就类似一个管家管理着我们的IO事件，不断的询问有没有准备好的IO事件有的话就会给对应的channal一把钥匙通知我们我线程去处理，这样就线程就不会一直阻塞在那里等到IO事件准备好才继续工作了，同时也实现可单个线程监听多个channal了。要实现我们的channal交给selector这个管家去管理，必须每个channal都要向selector注册事件。如下图：对于要注册感兴趣的IO事件，主要有以下几种：SelectionKey.OP_CONNECT（连接事件）SelectionKey.OP_ACCEPT（接收事件）SelectionKey.OP_READ （读事件）SelectionKey.OP_WRITE（写事件）这些数据的在我们的程序中正是用上面这四个常量来表示的，当然可以对多个感兴趣的事件进行注册我们可以用“或” 操作符来表示 SelectionKey.OP_READ | SelectionKey.OP_WRITE 注册事件后我们需要对selector进行轮询操作，当你的注册的事件已经准备就绪，那么regitor会返回一个selectionkey对象，这个对象包含了一些你感兴趣的属性： interest集合 —主要保存的是你感兴趣的事件集合。 ready集合 —主要保存的是已经准备好的事件结合 Channel —返回SelectionKey对应的channel Selector —返回SelectionKey对应的selector 附加的对象 —在selectionkey中添加一些附加信息使其更加方便的识别channel,比如可以附加和channal一起使用的buffer Buffers缓冲区，缓冲区是用来和通道交互的，通道是数据传输的途径，而缓冲区就是放入这些数据的一个对象。即我们要接收数据时总是从通道中获取数据放入已有的缓冲区，要发送数据时总是从已有的缓冲区写入通道中的，我们实际处理数据的来源正是缓冲区的数据。而缓冲区又有以下分类：ByteBufferMappedByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBuffer从以上可以看出，java中的八大基本数据类型除了boolean类型的都已经有与之相对应的缓冲类型。再来看看buffer中的一些属性的定义：capacity：容量，固定大小值，满了要清理或者读取才能继续写数据position：写模式时表示当前位置，最大值capacity – 1，切换到读模式时会被重置为0limit：读写数据的限制。写模式下等于capacity,读模式下等于写模式的position的值一些基本的用法：1.Buffer的分配：ByteBuffer.allocate（capacity）2.写数据到缓冲区： 从Channel写到Buffer：Channel.read(buf)，返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了） 通过Buffer的put()方法写到Buffer:buf.put() 3.flip()要读取数据时需要调用此方法将写模式切换到读模式,调用此方法后注意position和limit值得改变4.读数据，读模式下就可以读取之前写入的数据： 从Buffer读取数据到Channel:Channel.write(buf)，需要重复调用write(buf.hasRemaining())直到Buffer没有要写的字节为止 使用get()方法从Buffer中读取数据:buf.get() 5.清除缓冲区（为写作准备）： crear()清空整个缓冲区,position置0，未读的数据将会被遗忘 compact()清除已经读过的数据，将所有未读的数据拷贝到Buffer起始处，position为最后一个未读数据的后面 实践Demo上面已经把Channels，Selectors，Buffers简单的了解了一遍，所以接下来就要通过一个客户端和服务端通信的Demo去加深理解NIO的使用服务端： public class NioServer implements Runnable { // 记录连接数 private static int count = 0; // 选择器，用于管理向其注册的通道 private Selector selector; // 用于写数据的缓冲区 private ByteBuffer writeBuffer = ByteBuffer.allocate(1024); public NioServer(int port) { try { // 打开选择器， this.selector = Selector.open(); // 打开服务端通道 ServerSocketChannel server = ServerSocketChannel.open(); // 设置服务端通道为非阻塞 server.configureBlocking(false); // 绑定端口地址 server.bind(new InetSocketAddress(port)); // 把服务端通道注册到选择器上,并注册接受事件 server.register(selector, SelectionKey.OP_ACCEPT); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { // 轮询操作 while (true) { try { // 不断的监听就绪事件，返回值为就绪事件个数 int keys = selector.select(); if (keys &gt; 0) { // 遍历所有准备好的事件的channal对应的selectionkey Iterator&lt;SelectionKey&gt; selectionkeys = selector.selectedKeys().iterator(); while (selectionkeys.hasNext()) { // 获取其中一个selectionkey SelectionKey key = selectionkeys.next(); if (key.isValid()) { // 如果selectionkey是可接受状态 if (key.isAcceptable()) { // 处理可接收事件 handleAccept(key); } // 如果selectionkey是可读事件 if (key.isReadable()) { handleRead(key); } // 如果是可写事件 if (key.isWritable()) { handWrite(key); } } // 一定要记得从容器中移除，要不然会造成空轮询操作 selectionkeys.remove(); } } } catch (IOException e) { e.printStackTrace(); } } } private void handWrite(SelectionKey key) { // 由于写事件比较特殊，这里暂时不实现，下篇文章在继续实现 } private void handleRead(SelectionKey key) { try { // 用于读取数据的缓冲区 ByteBuffer readBuffer = ByteBuffer.allocate(1024); // 获取之前注册的读通道对象 SocketChannel socketChannel = (SocketChannel) key.channel(); // 读取数据 int count = socketChannel.read(readBuffer); // 如果没有数据 if (count == -1) { key.channel().close(); key.cancel(); count--; return; } // 如果有数据，那就进行读取，要把写模式切换为读模式 readBuffer.flip(); // 根据缓冲区的数据长度创建相应大小的byte数组，接收缓冲区的数据 byte[] bytes = new byte[readBuffer.remaining()]; // 接收缓冲区数据 readBuffer.get(bytes); String data = new String(bytes).trim(); System.out.println(&quot;客户端发送的数据为 : &quot; + data); } catch (IOException e) { e.printStackTrace(); } } private void handleAccept(SelectionKey key) { try { // 获取服务端的通道 ServerSocketChannel server = (ServerSocketChannel) key.channel(); // 获取到一个客户端连接的socketChannel SocketChannel socketChannel = server.accept(); // 设置为非阻塞 socketChannel.configureBlocking(false); // 把客户端的通道注册到选择器上，并且注册读事件 socketChannel.register(selector, SelectionKey.OP_READ); count++; System.out.println(&quot;当前有&quot; + count + &quot;个客户端连接&quot;); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { new Thread(new NioServer(9090)).start(); ; } } 客户端： public class NioClient{ public static void main(String[] args) { // 创建连接的地址 InetSocketAddress address = new InetSocketAddress(&quot;127.0.0.1&quot;, 9090); // 声明连接通道 SocketChannel sc = null; // 建立缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); try { // 打开通道 sc = SocketChannel.open(); // 进行连接 sc.connect(address); while (true) { // 定义一个字节数组，然后使用系统录入功能： byte[] bytes = new byte[1024]; System.in.read(bytes); // 把数据放到缓冲区中 buf.put(bytes); // 对缓冲区进行复位 buf.flip(); // 写出数据 sc.write(buf); // 清空缓冲区数据 buf.clear(); } } catch (IOException e) { e.printStackTrace(); } finally { if (sc != null) { try { sc.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 以上就是对NIO的简单入门，对于java NIO来说其API还是比较复杂的，想要写好可靠的NIO程序，还是需要不断的学习。有空在写一下NIO编程中存在的一些问题。参考：书籍： 《netty权威指南》文章： Java NIO 系列教程","categories":[],"tags":[{"name":"nio 网络编程","slug":"nio-网络编程","permalink":"http://52moyong.top/tags/nio-网络编程/"}]},{"title":"java8--StreamAPI","slug":"java8--StreamAPI","date":"2018-01-12T15:19:14.000Z","updated":"2018-05-24T09:04:33.739Z","comments":true,"path":"2018/01/12/java8--StreamAPI/","link":"","permalink":"http://52moyong.top/2018/01/12/java8--StreamAPI/","excerpt":"前言java8的新特性中引入了StreamAPI，是用来方便我们操作集合的。Stream是一个流的概念，我们只需要对流下达命令就可以对数据进行操作，有点类似于sql语句，我们只需要写好sql语句就能直接怼数据库的数据进行操作，即声明式的方式对数据进行处理，下面试简单的练习。","text":"前言java8的新特性中引入了StreamAPI，是用来方便我们操作集合的。Stream是一个流的概念，我们只需要对流下达命令就可以对数据进行操作，有点类似于sql语句，我们只需要写好sql语句就能直接怼数据库的数据进行操作，即声明式的方式对数据进行处理，下面试简单的练习。 StreamAPI的操作获取steamList&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;)); Stream&lt;Phone&gt; stream = list.stream(); 集合的筛选filter函数里面接收的是一个lambda表达式，如筛选出手机品牌为华为的手机： list.forEach(e-&gt;{System.out.println(&quot;过滤前：&quot;+e.getBrand());}); list=list.stream().filter(p-&gt;&quot;华为&quot;.equals(p.getBrand())).collect(Collectors.toList()); list.forEach(e-&gt;{System.out.println(&quot;过滤后：&quot;+e.getBrand());}); 去重，截取，跳过去重 List&lt;String&gt; lists=new ArrayList&lt;&gt;(); lists.add(&quot;h&quot;); lists.add(&quot;h&quot;); lists.add(&quot;2&quot;); lists = lists.stream().distinct().collect(Collectors.toList()); lists.forEach(p-&gt;{System.out.println(&quot;去重后：&quot;+p);}); 截取 List&lt;String&gt; lists=new ArrayList&lt;&gt;(); lists.add(&quot;h&quot;); lists.add(&quot;h&quot;); lists.add(&quot;2&quot;); lists = lists.stream().limit(2).collect(Collectors.toList()); lists.forEach(p-&gt;{System.out.println(&quot;截取后：&quot;+p);}); 跳过 List&lt;String&gt; lists=new ArrayList&lt;&gt;(); lists.add(&quot;h&quot;); lists.add(&quot;h&quot;); lists.add(&quot;2&quot;); lists = lists.stream().skip(2).collect(Collectors.toList()); lists.forEach(p-&gt;{System.out.println(&quot;跳过前两个后：&quot;+p);}); 映射映射在开发中用得还是比较频繁的。它是将一个list集合内的每一个元素类型根据需求映射成另一种类型的集合，map里面接收一个lamada表达式。例如列出所有手机的名称（即把一个phone类型的集合转变为String类型）： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;)); Stream&lt;Phone&gt; stream = list.stream(); List&lt;String&gt; phoneNames= stream.map(p-&gt;p.getName()).collect(Collectors.toList()); phoneNames.forEach(n-&gt;{System.out.println(n);}); 归约归约是指将集合的所有元素经过指定的运算，得到一个元素进行输出。如求最值，平均值等。reduce函数接收两个参数：一个初始值，一个lambda表达式。例如求手机的价格总和： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); List&lt;Integer&gt; prices = stream.map(p-&gt;p.getPrice()).collect(Collectors.toList()); int total=prices.stream().reduce(0, (p1,p2)-&gt;p1+p2); System.out.println(total); 或者reduce函数接收三个参数第一个参数是初始值，第二个参数是要进行规约操作的字段，第三个参数接收一个lambda表达式进行计算 Integer total = stream.collect(Collectors.reducing(0,Phone::getPrice,(p1,p2)-&gt;p1+p2)); 数值计算找出最贵的手机： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); //三种数值流IntStream、DoubleStream、LongStream IntStream intStream = stream.mapToInt(p-&gt;p.getPrice());//转换为数值流 OptionalInt maxPrice = intStream.max(); System.out.println(maxPrice.getAsInt()); 收集器的使用收集器用来对集合流操作后重新整理的后不同形式的展示。求最大值： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); Optional&lt;Phone&gt; maxPrice = stream.collect(Collectors.maxBy(Comparator.comparingInt(p-&gt;p.getPrice()))); System.out.println(maxPrice.get().getPrice()); 求平均值： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); Double avg = stream.collect(Collectors.averagingInt(p-&gt;p.getPrice())); System.out.println(avg); 求和： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); Integer sum = stream.collect(Collectors.summingInt(p-&gt;p.getPrice())); System.out.println(sum); 分组分组是对流中的元素按照指定的类别进行划分，和sql语句中的group by语句的作用类似。按照手机品牌进行分组： List&lt;Phone&gt; list=new ArrayList&lt;&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;,1688)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;,1999)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;,5200)); Stream&lt;Phone&gt; stream = list.stream(); Map&lt;String, List&lt;Phone&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Phone::getBrand)); for (Entry&lt;String, List&lt;Phone&gt;&gt; entry : map.entrySet()) { System.out.println(&quot;key组名:&quot;+entry.getKey()+&quot;value组内元素：&quot;+entry.getValue()); } 对分组进行统计： Map&lt;String, Long&gt; map = list.stream().collect(Collectors.groupingBy(p-&gt;p.getBrand(),Collectors.counting())); for (Entry&lt;String, Long&gt; entry : map.entrySet()) { System.out.println(&quot;key组名:&quot;+entry.getKey()+&quot;value组内元素个数：&quot;+entry.getValue()); } 总结以上就是对Steam API中常用的一些练习操作，值得注意的是Stream流只能遍历一次，只要对数据源操作过一遍了，那么这些数据就被消费掉了，如果在对这个流进行操作，那么就会抛出异常。当然我们可以从数据源在获取流继续操作。参考博客：Java8新特性——StreamAPI(一)","categories":[],"tags":[{"name":"-java8 -StreamAPI","slug":"java8-StreamAPI","permalink":"http://52moyong.top/tags/java8-StreamAPI/"}]},{"title":"java8新特性之Lambda表达式","slug":"java8新特性","date":"2017-12-12T13:59:44.000Z","updated":"2018-05-10T07:01:31.364Z","comments":true,"path":"2017/12/12/java8新特性/","link":"","permalink":"http://52moyong.top/2017/12/12/java8新特性/","excerpt":"前言前阵子java9已经出来了，但是请注意这里不是讲java9的新特性，因为java8的新特性笔者之前都没接触过~,毕竟自己做的项目没用上，所以就想着还是等工作的时候遇到了在进行学习吧，没想到实习的公司用到了很多java8的新特性（实习第二天，还是一直处于打酱油的状态(⊙o⊙)…），所以就开始了我的java8新特性的学习之路~~ Lambda表达式简介Lambda表达式是Java8里的一个重要特性，Lambda表达式其实就是提供Java编程中对于函数式编程的支持。Lambda表达式本质上是将一个函数的代码作为一个参数或变量进行传递，这种处理方式有个专门的名字——函数式编程 lambda表达式之基础语法","text":"前言前阵子java9已经出来了，但是请注意这里不是讲java9的新特性，因为java8的新特性笔者之前都没接触过~,毕竟自己做的项目没用上，所以就想着还是等工作的时候遇到了在进行学习吧，没想到实习的公司用到了很多java8的新特性（实习第二天，还是一直处于打酱油的状态(⊙o⊙)…），所以就开始了我的java8新特性的学习之路~~ Lambda表达式简介Lambda表达式是Java8里的一个重要特性，Lambda表达式其实就是提供Java编程中对于函数式编程的支持。Lambda表达式本质上是将一个函数的代码作为一个参数或变量进行传递，这种处理方式有个专门的名字——函数式编程 lambda表达式之基础语法 匿名内部类的简化以下是java8之前的内部类的写法：下面是java8中的写法：输出结果：首先很明显的看到java8的语法很简洁，省略了很多东西。经过一个小的Demo之后我们大概了解了lambda表达式的书写，我们在来看看他的语法是怎么样的,以下是三种写法：（）-&gt;单条语句（）-&gt;{多条语句}（）-&gt; 表达式 括号可以理解为没有名字的方法，里面是可以带参数的，而-&gt;指向的就是方法体的内容。即（参数1，参数2….）-&gt;{语句1；语句2},例如：（Param param1,Param param2…）-&gt;{param1+param2;system.printIn(“这是java8啊”)} 集合的遍历forEachjava8之前的集合遍历 ：java8之后的集合遍历 ：注：参数e的类型是由编译器推测出来的，也可以把类型加上 lambda表达式之进阶实战首先，先来看个需求：实现一个可以对List集合进行过滤的filter函数1.从List集合中筛选出性别为女的人。2.从List集合中筛选出品牌为华为的手机。在java8以前我们是通过匿名内部类实现的1.根据需求实现一个可以对集合元素的fiiter函数 public List&lt;T&gt; filter(List&lt;T&gt; list,IFilter iFilter){ List&lt;T&gt; result =new ArrayList&lt;T&gt;(); for(T t:list){ if(iFilter.filterMethod(t)){ result.add(t); } } return result; } 2.定义一个提供过滤的接口，不同的过滤方法只要实现这个接口就可以自定义过滤方法了 public interface IFilter &lt;T&gt;{ public boolean filterMethod(T t); } 3.然后就是实现具体的过滤方法3.1从List集合中筛选出性别为女的人: public static void main(String[] args) { LambdaTest&lt;Person&gt; test = new LambdaTest&lt;Person&gt;(); List&lt;Person&gt; list =new ArrayList&lt;Person&gt;(); list.add(new Person(&quot;张三&quot;,&quot;男&quot;)); list.add(new Person(&quot;李四&quot;,&quot;女&quot;)); List&lt;Person&gt; personList= test.filter(list,new IFilter&lt;Person&gt;() { @Override public boolean filterMethod(Person t) { if(&quot;女&quot;.equals(t.getSex())){ return true; } return false; } }); for (Person person : personList) { System.out.println(person.getName()); } } 输出结果： 李四 3.2从List集合中筛选出品牌为华为的手机。 public static void main(String[] args) { LambdaTest&lt;Phone&gt; test = new LambdaTest&lt;Phone&gt;(); List&lt;Phone&gt; list =new ArrayList&lt;Phone&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;)); List&lt;Phone&gt; phoneList= test.filter(list,new IFilter&lt;Phone&gt;() { @Override public boolean filterMethod(Phone p) { if(&quot;华为&quot;.equals(p.getBrand())){ return true; } return false; } }); for (Phone phone : phoneList) { System.out.println(phone.getName()); } 结果： 荣耀8 荣耀9 这是java8之前使用匿名内部类的解决方案，虽然整体上没什么问题，但是代码上不够简洁，让人看了很费劲。所以java8使用了lambda表达式简化我们的开发。java8实现3.1的需求： public static void main(String[] args) { LambdaTest&lt;Person&gt; test = new LambdaTest&lt;Person&gt;(); List&lt;Person&gt; list =new ArrayList&lt;Person&gt;(); list.add(new Person(&quot;张三&quot;,&quot;男&quot;)); list.add(new Person(&quot;李四&quot;,&quot;女&quot;)); List&lt;Person&gt; phoneList=test.filter(list, ( person)-&gt; &quot;女&quot;.equals(((Person) person).getSex())); phoneList.forEach(p-&gt;{System.out.println(p.getName());}); } 结果： 李四 java8实现3.2的需求： public static void main(String[] args) { LambdaTest&lt;Phone&gt; test = new LambdaTest&lt;Phone&gt;(); List&lt;Phone&gt; list =new ArrayList&lt;Phone&gt;(); list.add(new Phone(&quot;华为&quot;,&quot;荣耀8&quot;)); list.add(new Phone(&quot;华为&quot;,&quot;荣耀9&quot;)); list.add(new Phone(&quot;苹果&quot;,&quot;iphone8&quot;)); List&lt;Phone&gt; phoneList=test.filter(list, ( phone)-&gt; &quot;华为&quot;.equals(((Phone) phone).getBrand())); phoneList.forEach(p-&gt;{System.out.println(p.getName());}); } 结果： 荣耀8 荣耀9 哇，是不是看起来舒服很多，即简洁，可读性有好，但是接下来要讲的更重要的一件事情，上面的代码中我们定义了一个可以筛选出所需类型的接口，但是只是定义了筛选的一些共同的部分，具体的针对每个不同的筛选需求，具体的实现是根据筛选的需求规则而定的，这种模式称为策略模式。我们先来看一下策略模式的定义：即我们根据不同的需求提供了不同的筛选算法，而这些算法会根据使用者不同而随之变化。定义筛选方法的接口我们称之为抽象策略角色，不同的筛选算法，我们称之为具体的策略角色。在这里只是抛砖引玉的讲了一下策略模式，最近在项目中也遇到了有使用策略模式的地方，所以对此也有那么点理解，所谓的策略模式，相当于定义了一个入口，然后根据不同的需求执行不同的策略。使用这种模式能够很好的避免写很多重复的代码，而且能够好的管理不同的算法需求，可以很灵活的添加新的需求，使我们的代码结构更加的健壮。","categories":[],"tags":[{"name":"-java8 -lambda","slug":"java8-lambda","permalink":"http://52moyong.top/tags/java8-lambda/"}]},{"title":"关于实习的","slug":"shixi","date":"2017-12-09T01:45:42.000Z","updated":"2018-05-24T09:03:40.380Z","comments":true,"path":"2017/12/09/shixi/","link":"","permalink":"http://52moyong.top/2017/12/09/shixi/","excerpt":"找工作 我们学校本来是要求十一月份才可以出去实习的，但是我们的专业大四只有一门课程，而且还是感觉没啥意义的课程，所以寻思着国庆后开始复习以前学过的java知识，然后出去找实习（笔者学渣一枚，大学基本没怎么听课，而且学习java的时间也比较短，知识储备不够。所以走校招根本没啥优势，只能自己找），国庆的时候就把java基础和web部分简单的复习了一遍，框架部分感觉不知道该怎么复习，所以只是大概的浏览了一下，一些比较重要的知识点。然后就开始信心满满的投简历了(⊙o⊙)…一共在智联投了三份简历。很高兴，刚投简历没到5分钟就收到了面试通知（当时激动坏了），约好是第二天下午面试，然后就在网上找了一篇面试题看了一遍。然后晚上早早的就上床休息了，但是没想到的是晚上竟然失眠了，哭~~像是吃了兴奋剂似的，脑袋异常的活跃。翻来覆去就是睡不着。印象中应该是差不多凌晨四点左右才睡着的，第二天早上七点就起来了，才睡了三个小时,然后开始赶车，几经周折终于到了面试的地点，先是做一份面试题，由于第一次参加笔试面试，所以题目还是记得比较清楚。先是做笔试题:","text":"找工作 我们学校本来是要求十一月份才可以出去实习的，但是我们的专业大四只有一门课程，而且还是感觉没啥意义的课程，所以寻思着国庆后开始复习以前学过的java知识，然后出去找实习（笔者学渣一枚，大学基本没怎么听课，而且学习java的时间也比较短，知识储备不够。所以走校招根本没啥优势，只能自己找），国庆的时候就把java基础和web部分简单的复习了一遍，框架部分感觉不知道该怎么复习，所以只是大概的浏览了一下，一些比较重要的知识点。然后就开始信心满满的投简历了(⊙o⊙)…一共在智联投了三份简历。很高兴，刚投简历没到5分钟就收到了面试通知（当时激动坏了），约好是第二天下午面试，然后就在网上找了一篇面试题看了一遍。然后晚上早早的就上床休息了，但是没想到的是晚上竟然失眠了，哭~~像是吃了兴奋剂似的，脑袋异常的活跃。翻来覆去就是睡不着。印象中应该是差不多凌晨四点左右才睡着的，第二天早上七点就起来了，才睡了三个小时,然后开始赶车，几经周折终于到了面试的地点，先是做一份面试题，由于第一次参加笔试面试，所以题目还是记得比较清楚。先是做笔试题: 1.重载和重写的区别 2.使用原生的js使用三种方式定位标签，并说明含义（大概是这个意思） 3.什么是mvc模式，请画出mvc模式运行时的时序图（当时没画图） 4.然后是两页代码，看完后写出这两页代码是做什么的，（晕了，毕竟昨晚失眠了，好像是关于存储过程的调用，对那块不是很熟悉，所以也没写出来） 5.手写单例模式，能写多少种就写多少种 6.jdbc的执行流程 7.给两张表，写sql语句 写完后给人事，人事拿给技术部的，然后跟我说java实习已经招满了，要不要尝试做实施或者运维，我说对这个不是很了解，然后又跟我说会有人教我的，但是我还是拒绝了，然后叫我等一下，她在拿去给技术部的看看，后面叫了一个好像是搞运维的来面我，面试有点紧张，只记得一点点了： 1.自我介绍 2.愿不愿意搞运维（晕） 3.hibernate的实现原理 4.js,css,html这些都熟悉么 5.说说redis 6.平时sql写的很少么？看你写的sql有点问题呢（哭） 7.有没有使用过什么中间件技术 8.叫我设计一个网络实现通信该怎么弄（不太记得了，当时也没明白他说的是啥意思） 只记得那么多了，毕竟第一次面试还是挺紧张的，加上失眠。。。。然后就叫我回去等通知了。。。 还有一家是我去学校的时候才给我打电话的，是电话面试。 1.创建对象有哪几种方式 2.什么是线程 3.线程有几种状态 4.索引的作用 5.问了一下我的专业 6.Linux了解么 7.说一下常用的命令操作 8.聊了一些其他东西 9.问我什么时候能来上班 这家公司已经拿到offer,也去了但是由于一些原因。就没有留下来。然后就是想着回家先把毕设做出来，回家之后先休息了一段时间，然后才开始做毕设，毕设感觉简直是折磨啊，以前没写过前端的东西，html,css,布局啥的都不知道该怎么设计，做了三天才勉强把主页给弄出来。然后又不是很想做了，就自己找了个项目练练。打算12月份出去找工作。 12月份找实习也是很坑爹，几乎都不招实习生了，没办法，只能乱投，有面试机会就上，但是接到面试邀请的也少，其他的就不记录了，就说说现在拿到offer的这家公司，过两天就要去报道了，所以蹭着还有时间，就简单的记录一下，这家公司是个小公司，具体来说应该算是创业团队吧，被录取了竟然是在boss直聘上通知的，简单的说一下面试过程吧。也是先做笔试题，然后才开始面试。没有自我介绍。直接上来怼技术。 1.看了我的专业，问我是不是自学的，学了多久 2.值传递和引用传递，哪个变，哪个不变 3.说一下jdbc 4.说一下事务 5.jsp哪部分是在浏览器执行的，哪部分是在服务端执行的 6.单例模式的作用是什么 7.说一下多线程 8.线程安全问题怎么解决 9.说说jvm的内存结构 10.分别说下新生代，老年代，永久代的划分 11.聊项目。。 12.还有什么要问的。 大该就是这么多，还有一些问题可能想不起来了，毕竟聊了也蛮久的，也是我遇到的比较有好的面试了（不过我的面试经历也很少，，哈哈） 虽然这家公司做的是传统行业，而且用的技术也不是新，就暂且尝试一下，锻炼锻炼自己吧。 实习的计划 1.把公司的业务弄熟，尽量能为公司做出贡献 2.巩固自己的基础，把基础打牢 3.尽快的把毕业设计弄完 4.坚持锻炼 5.熟悉一些技术的原理：打算从操作系统开始看起，然后在深入jvm,然后到多线程并发相关。 6.坚持一个星期能写出一篇博客。 7.坚持看书。 小结 刚刚把博客搭建起来，第一次写博客，也不知道该写啥，所以就写点随笔，把自己找工作的经历写下来，写的不是很好，都是想到什么就写什么，没啥思路，面试的时候也是一样，回答问题思路总是不是很清晰，想到什么就回答什么，导致面试官可能对我的印象不是很好，希望自己能够坚持写博客吧，把自己学习到的知识记录下来，加上自己的理解，把自己的思路打通，以后面试才能表现的更好。加油！！","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://52moyong.top/tags/随笔/"}]}]}